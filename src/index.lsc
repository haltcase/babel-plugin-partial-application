DEFAULT_PLACEHOLDER = '_'
ALTERNATE_PLACEHOLDER = '__'

makeIdentifierError (path, current) ->
  path.buildCodeFrameError(
    `Cannot use placeholder as an identifier.\n
     If you need to use '${current}' as a variable name:
     - set 'options.placeholder' to a different custom token
     - set 'options.useAlternatePlaceholder' for '__'
       ( a double underscore )\n
    See https://github.com/citycide/babel-plugin-partial-application#caveats--limitations
    for more information.\n`
  )

module.exports = ({ types: t }) ->
  getPlaceholder (state) ->
    let {
      placeholder = DEFAULT_PLACEHOLDER,
      useAlternatePlaceholder
    } = state.opts

    if placeholder == DEFAULT_PLACEHOLDER and useAlternatePlaceholder:
      now placeholder = ALTERNATE_PLACEHOLDER

    kind = typeof placeholder
    if kind != 'string':
      throw new TypeError(
        'Expected a string for `options.placeholder` ' +
        `and got ${kind}`
      )

    placeholder

  isPlaceholder (node, placeholder) ->
    t.isIdentifier(node, { name: placeholder })

  isSpreadPlaceholder (node, placeholder) ->
    t.isSpreadElement(node) and isPlaceholder(node.argument, placeholder)

  isSomePlaceholder (node, placeholder) ->
    isPlaceholder(node, placeholder) or isSpreadPlaceholder(node, placeholder)

  hasPlaceholders (nodes, placeholder) ->
    for elem node in nodes:
      if isPlaceholder(node, placeholder):
        return true

  getUniqueName (path, name = 'a') ->
    path.scope.generateUidIdentifier(name)

  checkImports (path, placeholder) ->
    for elem specifier in path.node.specifiers:
      if specifier.local.name == placeholder:
        throw makeIdentifierError(path, placeholder)

  checkDeclarations (path, placeholder) ->
    for elem declaration in path.node.declarations:
      if declaration.id.name == placeholder:
        throw makeIdentifierError(path, placeholder)

  partiallyApply (path, placeholder) ->
    { arguments: args, callee } = path.node
    remainingParams = []

    nextCallParams = args.map(arg =>
      if !isSomePlaceholder(arg, placeholder):
        return arg

      if isPlaceholder(arg, placeholder):
        name = getUniqueName(path)
        remainingParams.push(name)
        return name

      if isSpreadPlaceholder(arg, placeholder):
        name = getUniqueName(path)
        remainingParams.push(t.restElement(name))
        return t.spreadElement(name)
    )

    path.replaceWith(
      t.arrowFunctionExpression(
        remainingParams,
        t.blockStatement([
          t.returnStatement(
            t.callExpression(
              callee,
              nextCallParams
            )
          )
        ])
      )
    )

  return {
    visitor: {
      ImportDeclaration (path, state) ->
        checkImports(path, getPlaceholder(state))

      VariableDeclaration (path, state) ->
        checkDeclarations(path, getPlaceholder(state))

      CallExpression (path, state) ->
        placeholder = getPlaceholder(state)
        { arguments: args } = path.node

        if args.length and hasPlaceholders(args, placeholder):
          partiallyApply(path, placeholder)

      MemberExpression (path, state) ->
        placeholder = getPlaceholder(state)
        { parent, node: { object, property } } = path

        if !isPlaceholder(object, placeholder): return

        id = getUniqueName(path)
        exp = t.memberExpression(id, property)
        ret = t.isCallExpression(parent)
          ? t.callExpression(exp, parent.arguments)
          : exp

        path.replaceWith(
          t.arrowFunctionExpression(
            [id],
            t.blockStatement([
              t.returnStatement(ret)
            ])
          )
        )

        path.stop()

      SpreadElement (path, state) {
        placeholder = getPlaceholder(state)
        { parent, parentPath, node: { argument } } = path

        if !isPlaceholder(argument, placeholder): return

        id = path.scope.generateUidIdentifier('a')
        args = parent.arguments.slice(0, -1)

        parentPath.replaceWith(
          t.arrowFunctionExpression(
            [t.restElement(id)],
            t.blockStatement([
              t.returnStatement(
                t.callExpression(
                  parent.callee,
                  [...args, t.spreadElement(id)]
                )
              )
            ])
          )
        )

        parentPath.stop()
      }
    }
  }
